import simpleGit from 'simple-git';
import path from 'path';
import { fileURLToPath } from 'url';
import { getConfig } from '../config/index.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = path.resolve(__dirname, '../..');

/**
 * Git Service for automatic repository management
 */
class GitService {
  constructor() {
    this.git = simpleGit(PROJECT_ROOT);
    this.config = getConfig();
  }

  /**
   * Initialize git repository if not already initialized
   * @returns {Promise<void>}
   */
  async initializeRepository() {
    try {
      const isRepo = await this.git.checkIsRepo();
      
      if (!isRepo) {
        console.log('Initializing git repository...');
        await this.git.init();
        
        // Add remote if configured
        if (this.config.github.username && this.config.github.repo) {
          const remoteUrl = `https://github.com/${this.config.github.username}/${this.config.github.repo}.git`;
          await this.git.addRemote('origin', remoteUrl);
          console.log(`Added remote origin: ${remoteUrl}`);
        }
      }
    } catch (error) {
      console.error('Failed to initialize repository:', error);
      throw error;
    }
  }

  /**
   * Configure git user if not already configured
   * @returns {Promise<void>}
   */
  async configureGitUser() {
    try {
      const config = await this.git.listConfig();
      
      if (!config.all['user.name']) {
        await this.git.addConfig('user.name', 'Mathematical Everyday Bot');
      }
      
      if (!config.all['user.email']) {
        await this.git.addConfig('user.email', 'mathematical-everyday@bot.local');
      }
    } catch (error) {
      console.error('Failed to configure git user:', error);
      throw error;
    }
  }

  /**
   * Add and commit changes to the repository
   * @param {string} message - Commit message
   * @param {Array<string>} files - Optional array of specific files to add
   * @returns {Promise<Object>} Commit result
   */
  async commitChanges(message, files = null) {
    try {
      await this.configureGitUser();
      
      // Add files
      if (files && files.length > 0) {
        for (const file of files) {
          await this.git.add(file);
        }
      } else {
        await this.git.add('.');
      }
      
      // Check if there are changes to commit
      const status = await this.git.status();
      if (status.files.length === 0) {
        console.log('No changes to commit');
        return { committed: false, message: 'No changes to commit' };
      }
      
      // Commit changes
      const commitResult = await this.git.commit(message);
      console.log(`Committed changes: ${message}`);
      
      return {
        committed: true,
        hash: commitResult.commit,
        message: message,
        files: status.files.length
      };
    } catch (error) {
      console.error('Failed to commit changes:', error);
      throw error;
    }
  }

  /**
   * Push changes to remote repository
   * @param {string} branch - Branch name (default: main)
   * @returns {Promise<Object>} Push result
   */
  async pushToRemote(branch = 'main') {
    try {
      if (!this.config.github.token) {
        throw new Error('GitHub token not configured');
      }

      // Set up authentication for GitHub
      const remoteUrl = `https://${this.config.github.token}@github.com/${this.config.github.username}/${this.config.github.repo}.git`;
      
      // Update remote URL with token
      try {
        await this.git.removeRemote('origin');
      } catch (e) {
        // Remote might not exist, that's ok
      }
      await this.git.addRemote('origin', remoteUrl);
      
      // Push to remote
      const pushResult = await this.git.push('origin', branch);
      console.log(`Pushed to ${branch} branch`);
      
      return {
        pushed: true,
        branch: branch,
        result: pushResult
      };
    } catch (error) {
      console.error('Failed to push to remote:', error);
      throw error;
    }
  }

  /**
   * Commit and push a new problem
   * @param {Object} problemData - Problem data object
   * @param {string} filePath - Path to the problem file
   * @returns {Promise<Object>} Operation result
   */
  async commitNewProblem(problemData, filePath) {
    try {
      const date = new Date().toISOString().split('T')[0];
      const message = `Add new ${problemData.category} problem for ${date}

üìö È¢òÁõÆ: ${problemData.title}
üè∑Ô∏è ÂàÜÁ±ª: ${problemData.category}
üìä ÈöæÂ∫¶: ${problemData.difficulty}
ü§ñ Generated by AI`;

      // Commit the changes
      const commitResult = await this.commitChanges(message, [filePath]);
      
      if (!commitResult.committed) {
        return commitResult;
      }

      // Push to remote if configured
      let pushResult = { pushed: false };
      if (this.config.github.token && this.config.github.username && this.config.github.repo) {
        try {
          pushResult = await this.pushToRemote();
        } catch (error) {
          console.error('Failed to push, but commit was successful:', error);
          pushResult = { pushed: false, error: error.message };
        }
      }

      return {
        ...commitResult,
        ...pushResult,
        problemTitle: problemData.title,
        category: problemData.category
      };
    } catch (error) {
      console.error('Failed to commit new problem:', error);
      throw error;
    }
  }

  /**
   * Commit and push a solution update
   * @param {Object} problemData - Problem data object
   * @param {string} filePath - Path to the problem file
   * @returns {Promise<Object>} Operation result
   */
  async commitSolution(problemData, filePath) {
    try {
      const date = new Date().toISOString().split('T')[0];
      const message = `Add solution for ${problemData.category} problem

üìö È¢òÁõÆ: ${problemData.title}
‚úÖ Ëß£Á≠î: Solution added
üìÖ Êó•Êúü: ${date}
ü§ñ Generated by AI`;

      // Commit the changes
      const commitResult = await this.commitChanges(message, [filePath]);
      
      if (!commitResult.committed) {
        return commitResult;
      }

      // Push to remote if configured
      let pushResult = { pushed: false };
      if (this.config.github.token && this.config.github.username && this.config.github.repo) {
        try {
          pushResult = await this.pushToRemote();
        } catch (error) {
          console.error('Failed to push, but commit was successful:', error);
          pushResult = { pushed: false, error: error.message };
        }
      }

      return {
        ...commitResult,
        ...pushResult,
        problemTitle: problemData.title,
        category: problemData.category,
        type: 'solution'
      };
    } catch (error) {
      console.error('Failed to commit solution:', error);
      throw error;
    }
  }

  /**
   * Get repository status
   * @returns {Promise<Object>} Repository status
   */
  async getStatus() {
    try {
      const status = await this.git.status();
      const log = await this.git.log({ maxCount: 5 });
      
      return {
        branch: status.current,
        ahead: status.ahead,
        behind: status.behind,
        modified: status.modified.length,
        created: status.created.length,
        deleted: status.deleted.length,
        renamed: status.renamed.length,
        recentCommits: log.all.map(commit => ({
          hash: commit.hash.substring(0, 7),
          message: commit.message,
          date: commit.date,
          author: commit.author_name
        }))
      };
    } catch (error) {
      console.error('Failed to get repository status:', error);
      throw error;
    }
  }

  /**
   * Create initial repository structure
   * @returns {Promise<void>}
   */
  async createInitialStructure() {
    try {
      await this.initializeRepository();
      
      // Create initial commit if repository is empty
      const log = await this.git.log().catch(() => null);
      
      if (!log || log.total === 0) {
        await this.commitChanges('Initial commit: Mathematical Everyday project setup');
        
        if (this.config.github.token && this.config.github.username && this.config.github.repo) {
          await this.pushToRemote();
        }
      }
    } catch (error) {
      console.error('Failed to create initial structure:', error);
      throw error;
    }
  }
}

export default GitService;
